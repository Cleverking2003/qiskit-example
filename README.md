# Отчет по курсу "Квантовые вычисления на Python с использованием Qiskit"

## Введение
Целью нашего курса является изучение основ квантовых вычислений и знакомство с их возможностями через реализацию алгоритмов различной сложности на платформе Qiskit. Мы начнем с базовых примеров, которые помогут понять фундаментальные концепции, такие как суперпозиция, запутанность и измерение в квантовых системах. По мере углубления мы перейдем к более сложным задачам, таким как квантовая криптография, симуляция квантовой динамики и квантовая коррекция ошибок. Эти темы продемонстрируют как уникальные свойства квантовых систем, так и их преимущества для решения задач, сложных для классических компьютеров.

## Теория
### Основные принципы квантовых вычислений

1. **Кубит**  
   В классических вычислениях бит может находиться в одном из двух состояний: 0 или 1. Кубит, однако, может находиться как в состояниях \( |0\rangle \) и \( |1\rangle \), так и в их суперпозиции, описываемой как \( |\psi\rangle = \alpha|0\rangle + \beta|1\rangle \), где \( \alpha \) и \( \beta \) — комплексные числа, удовлетворяющие условию нормировки \( |\alpha|^2 + |\beta|^2 = 1 \). Суперпозиция позволяет кубиту существовать одновременно в обоих состояниях с определенной вероятностью, что дает возможность проводить параллельные вычисления.

2. **Суперпозиция**  
   Это одно из ключевых свойств, отличающее квантовые компьютеры от классических. Если классический бит фиксирован в одном из двух значений, то кубит может быть в суперпозиции, то есть одновременно представлять 0 и 1. Это позволяет квантовым компьютерам исследовать несколько путей вычислений одновременно.

3. **Запутанность (энтэнглмент)**  
   Кубиты могут быть «запутаны», что означает, что их состояния связаны, даже если они находятся на большом расстоянии друг от друга. Это свойство позволяет создать корреляции между кубитами, что необходимо для квантовой передачи данных и квантовой криптографии. Запутанность позволяет квантовым системам передавать информацию и вычислять состояния более эффективно, чем классические системы.

4. **Измерение**  
   В квантовых вычислениях результат считывается через измерение состояния кубитов. При измерении кубит «коллапсирует» в одно из возможных классических состояний, \( |0\rangle \) или \( |1\rangle \), с определенной вероятностью. Это значит, что квантовая информация не может быть скопирована напрямую, как в классических системах (это является следствием теоремы о запрете клонирования).

5. **Интерференция**  
   В квантовых алгоритмах состояния могут интерферировать друг с другом. Правильная настройка интерференции позволяет усилить вероятности нужных результатов и ослабить вероятности ненужных, что повышает точность и эффективность квантовых алгоритмов.

### Основные квантовые гейты

В квантовых вычислениях гейт (или квантовый логический элемент) — это базовая операция, выполняемая над кубитами, которая изменяет их состояние. Подобно тому, как классические логические элементы (например, AND, OR, NOT) выполняют операции над битами в традиционных вычислениях, квантовые гейты манипулируют кубитами с учетом квантовых эффектов, таких как суперпозиция и запутанность.

Квантовые гейты выполняют операции над кубитами, аналогично логическим гейтам в классических компьютерах. Основные гейты включают:

- **Гейт Паули-X**: Аналогичен классической операции NOT и инвертирует состояния \( |0\rangle \) и \( |1\rangle \).
- **Гейт Паули-Y и Паули-Z**: Эти гейты изменяют фазу состояния кубита и также необходимы для манипуляций со квантовыми состояниями.
- **Hadamard-гейт (H)**: Применение этого гейта к кубиту переводит его в состояние суперпозиции, где оба состояния \( |0\rangle \) и \( |1\rangle \) имеют равную вероятность.
- **CNOT-гейт (CX)**: Это контролируемый гейт, который инвертирует состояние второго кубита, если первый кубит находится в состоянии \( |1\rangle \).
- **Фазовый гейт**: Этот гейт изменяет фазу состояния кубита, что играет важную роль в реализации таких алгоритмов, как квантовая фурье-трансформация.

Эти гейты являются базовыми строительными блоками для построения квантовых алгоритмов. 

## Оракулы в квантовых вычислениях

**Оракул** — это квантовая подпрограмма или черный ящик, реализующий специфическую функцию \( f(x) \), которую можно применять к квантовым состояниям для извлечения полезной информации. Основная роль оракула в квантовых алгоритмах заключается в том, чтобы указать состояние, содержащее решение задачи, или преобразовать входные данные таким образом, чтобы решение стало более очевидным после использования квантовых операций, таких как суперпозиция и интерференция. 


## Исследование

### 001. Базовые операции с кубитами
Создаём простую квантовую схему с одним кубитом.
Инициализируем один кубит.
Применим к кубиту гейт Хадамара для перехода в суперпозицию.
Выполним измерение и выведем результаты измерений.


### 002. Создание запутанных состояний
Запутанность — это важное свойство кубитов, необходимое для работы многих квантовых алгоритмов.
Создаём запутанное состояние, используя операторы Hadamard и CNOT.
Измеряем распределение результатов, где оба кубита находятся в одинаковом состоянии.


### 003. Алгоритм Дойча-Йожи
Алгоритм решает простую задачу и является хорошим примером использования квантовых вычислений.
Создаём две версии квантовой схемы для различных оракулов.
Алгоритм возвращает результат измерения, по которому можно определить, является ли функция сбалансированной или константной.


### 004. Выполнение схемы на реальном квантовом процессоре IBM
Qiskit позволяет запускать квантовые схемы на реальном квантовом компьютере. 
Получим токен доступа на IBM Quantum.


### 005. Квантовая телепортация
Квантовая телепортация — это передача состояния кубита от одного к другому при помощи запутанности и классической информации.
Создаём схему, состоящую из трех кубитов, где состояние первого кубита передается третьему кубиту через запутывание и измерения.


### 006. Квантовый алгоритм Гровера
Алгоритм Гровера — это алгоритм для поиска элемента в неупорядоченном массиве с квадратичным ускорением по сравнению с классическим поиском.
Создаём оракул и применяем к нему оператор Гровера для поиска нужного состояния.


### 007. Алгоритм Шора для факторизации
Алгоритм Шора — это квантовый алгоритм для факторизации целых чисел. Поскольку факторизация чисел требует больших вычислительных ресурсов, здесь мы используем симулятор с упрощенной версией алгоритма.
В Qiskit представлена упрощенная версия алгоритма Шора для факторизации числа 15.
Используя алгоритм Шора, мы выполним факторизацию числа 15. Этот алгоритм требует значительных ресурсов для более сложных чисел, поэтому он обычно запускается на специализированных симуляторах или реальных квантовых процессорах.


### 008. Квантовая ошибка и коррекция ошибок
В квантовых вычислениях ошибки возникают из-за потерь когерентности. Qiskit позволяет создавать коды коррекции ошибок для минимизации этих эффектов.
Трехкубитный код коррекции ошибок
Мы создали простой код коррекции ошибок, который позволяет обнаружить и исправить одиночную ошибку на одном из кубитов


### 009. Построение собственных квантовых оракулов
В некоторых алгоритмах, таких как Гровер, требуется построить собственный оракул для поиска. Qiskit позволяет создавать произвольные оракулы.
Мы построили пользовательский оракул для состояния |11⟩ и применили его в квантовой схеме, подобной алгоритму Гровера


### 010. Квантовая криптография и протокол BB84
Протокол BB84 — это метод квантового распределения ключей (QKD), который позволяет двум сторонам безопасно обмениваться ключом.
Этот код реализует распределение ключа, где Алиса и Боб случайным образом выбирают базисы и квантовые биты. После измерения они сопоставляют базисы, и результаты измерения используются для генерации секретного ключа.

### 011. Вариационный алгоритм квантовой аппроксимационной оптимизации (QAOA)
QAOA — это алгоритм для решения комбинаторных задач оптимизации, таких как задача коммивояжера или задачи раскраски графов.
Мы используем библиотеку qiskit_optimization для преобразования задачи MaxCut в оператор квантовой энергии (гамильтониан), затем применяем QAOA для поиска оптимального разреза графа. Результат показывает минимальное значение гамильтониана и оптимальные параметры.

### 012. Вариационный алгоритм нахождения основного состояния (VQE)
Вариационный алгоритм нахождения основного состояния (VQE) используется для нахождения минимального состояния энергии молекул, что применимо в квантовой химии.
Здесь мы находим минимальное состояние энергии для молекулы водорода, моделируя молекулу и её взаимодействия в квантовой цепи и применяя VQE для получения минимального энергетического уровня.

### 013. Квантовые нейронные сети (QNN)
Квантовые нейронные сети (QNN) являются комбинацией квантовых вычислений и машинного обучения и могут использоваться для решения задач классификации и регрессии.
Мы создали квантовую нейронную сеть для классификации, используя TwoLayerQNN и обучив модель на симуляторе. Этот подход позволяет использовать квантовые характеристики для обучения на данных.

### 014. Адъюнтатные методы и квантовый градиентный спуск
Градиентный спуск позволяет оптимизировать квантовые схемы с помощью градиентных вычислений. Это особенно полезно для обучения параметрических квантовых схем.
Здесь используется метод для вычисления градиента параметра квантовой схемы. Градиент помогает оптимизировать параметры, что особенно важно в вариационных квантовых алгоритмах.

### 015. Квантовая Фурье-трансформация (QFT)
Квантовая фурье-трансформация (QFT) — это квантовый аналог дискретного преобразования Фурье. Она используется в квантовых алгоритмах, таких как алгоритм Шора, для преобразования кубитных состояний.
Здесь реализована QFT на 3 кубитах. Цепь применяет последовательность Hadamard и контролируемых фазовых гейтов для реализации преобразования Фурье.

### 016. Моделирование квантовой динамики: эволюция Шредингера
Описание: Квантовая динамика описывает, как квантовые состояния изменяются со временем под воздействием гамильтониана H, используя уравнение Шредингера. Qiskit позволяет проводить такие симуляции, что применимо в квантовой химии и физике.

Мы создали гамильтониан и вычислили эволюцию начального состояния с учетом действия гамильтониана. Такое моделирование используется в квантовой химии и физике для симуляции эволюции сложных систем.

### 017. Квантовая коррекция ошибок: поверхностный код (surface code)
Поверхностный код — это схема коррекции ошибок для квантовых компьютеров, которая использует решеточную структуру кубитов и защищает от ошибок через топологические свойства.
Описание кода: Эта цепь демонстрирует упрощенную реализацию поверхностного кода для кодирования и декодирования логического кубита. В реальных системах поверхностный код строится на сетке и включает многоуровневую схему проверки ошибок.

### 018. Квантовая теория информации: Энтропия фон Неймана и взаимная информация
Энтропия фон Неймана является мерой неопределенности в квантовой системе, тогда как взаимная информация позволяет измерить перепутанность между частями квантовой системы.
Этот код создает запутанное состояние Белла и вычисляет его энтропию фон Неймана и взаимную информацию. Эти величины используются в квантовой теории информации для измерения количества информации и степени запутанности.

### 019. Квантовый алгоритм Гамильтоновой симуляции для больших систем
Гамильтонова симуляция позволяет моделировать эволюцию больших квантовых систем, например, для молекул, атомов или даже квантовых материалов.
В этом коде моделируется эволюция сложного гамильтониана с использованием метода троттеризации, что позволяет эффективно симулировать эволюцию сложных систем на квантовом компьютере.

### 020. Гибридные классические и квантовые алгоритмы для задач машинного обучения
Квантовые компьютеры могут быть интегрированы с классическими алгоритмами для решения больших задач машинного обучения (например, кластеризация, классификация), где квантовый процесс используется для ускорения вычислений.
Этот код реализует гибридную квантово-классическую модель SVC для классификации данных. Квантовая часть работает через feature map, а оптимизация параметров выполняется классическим образом.


## Заключение

В ходе нашего исследования мы познакомились с широким спектром возможностей квантовых вычислений, от простых реализаций базовых квантовых операций до сложных квантовых алгоритмов и систем коррекции ошибок. 

Благодаря пошаговому изучению от простого к сложному, мы смогли постепенно осознать, как работают квантовые алгоритмы, и понять, каким образом квантовые вычисления могут изменить подход к решению сложных задач в области криптографии, оптимизации, моделирования и машинного обучения.


## Источники:
Кайзер С., Гранад К. Изучаем квантовые вычисления на Python и Q# / пер. с анг. А. В. Логунова. – М.: ДМК Пресс, 2021
