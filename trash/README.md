# Отчет по курсу "Квантовые вычисления на Python с использованием Qiskit"


## Содержание
1. [Введение](#1)
2. [Теория](#2)
3. [План исследования](#3)
4. [Настройка окружения](#4)
5. [Результаты исследования](#5)
6. [Источники](#6)
7. [Авторы](#7)

## Введение <a name="1"></a>
Целью нашего курса является изучение основ квантовых вычислений и знакомство с их возможностями через реализацию алгоритмов различной сложности на платформе Qiskit. Мы начнем с базовых примеров, которые помогут понять фундаментальные концепции, такие как суперпозиция, запутанность и измерение в квантовых системах. По мере углубления мы перейдем к более сложным задачам, таким как квантовая криптография, симуляция квантовой динамики и квантовая коррекция ошибок. Эти темы продемонстрируют как уникальные свойства квантовых систем, так и их преимущества для решения задач, сложных для классических компьютеров.

## Теория <a name="2"></a>
### Основные принципы квантовых вычислений

1. **Кубит**  
   В классических вычислениях бит может находиться в одном из двух состояний: 0 или 1. Кубит, однако, может находиться как в состояниях |0⟩ и |1⟩, так и в их суперпозиции, описываемой как |ψ⟩ = α|0⟩ + β|1⟩
, где α и β — комплексные числа, удовлетворяющие условию нормировки β|α|^2 + |β|^2 = 1. Суперпозиция позволяет кубиту существовать одновременно в обоих состояниях с определенной вероятностью, что дает возможность проводить параллельные вычисления.

2. **Суперпозиция**  
   Это одно из ключевых свойств, отличающее квантовые компьютеры от классических. Если классический бит фиксирован в одном из двух значений, то кубит может быть в суперпозиции, то есть одновременно представлять 0 и 1. Это позволяет квантовым компьютерам исследовать несколько путей вычислений одновременно.

3. **Запутанность (энтэнглмент)**  
   Кубиты могут быть «запутаны», что означает, что их состояния связаны, даже если они находятся на большом расстоянии друг от друга. Это свойство позволяет создать корреляции между кубитами, что необходимо для квантовой передачи данных и квантовой криптографии. Запутанность позволяет квантовым системам передавать информацию и вычислять состояния более эффективно, чем классические системы.

4. **Измерение**  
   В квантовых вычислениях результат считывается через измерение состояния кубитов. При измерении кубит «коллапсирует» в одно из возможных классических состояний, |0⟩ или |1⟩, с определенной вероятностью. Это значит, что квантовая информация не может быть скопирована напрямую, как в классических системах (это является следствием теоремы о запрете клонирования).

5. **Интерференция**  
   В квантовых алгоритмах состояния могут интерферировать друг с другом. Правильная настройка интерференции позволяет усилить вероятности нужных результатов и ослабить вероятности ненужных, что повышает точность и эффективность квантовых алгоритмов.

### Основные квантовые гейты

В квантовых вычислениях гейт (или квантовый логический элемент) — это базовая операция, выполняемая над кубитами, которая изменяет их состояние. Подобно тому, как классические логические элементы (например, AND, OR, NOT) выполняют операции над битами в традиционных вычислениях, квантовые гейты манипулируют кубитами с учетом квантовых эффектов, таких как суперпозиция и запутанность.

Квантовые гейты выполняют операции над кубитами, аналогично логическим гейтам в классических компьютерах. Основные гейты включают:

- **Гейт Паули-X**: Аналогичен классической операции NOT и инвертирует состояния |0⟩ и |1⟩.
- **Гейт Паули-Y и Паули-Z**: Эти гейты изменяют фазу состояния кубита и также необходимы для манипуляций со квантовыми состояниями.
- **Hadamard-гейт (H)**: Применение этого гейта к кубиту переводит его в состояние суперпозиции, где оба состояния |0⟩ и |1⟩ имеют равную вероятность.
- **CNOT-гейт (CX)**: Это контролируемый гейт, который инвертирует состояние второго кубита, если первый кубит находится в состоянии |1⟩.
- **Фазовый гейт**: Этот гейт изменяет фазу состояния кубита, что играет важную роль в реализации таких алгоритмов, как квантовая фурье-трансформация.

Эти гейты являются базовыми строительными блоками для построения квантовых алгоритмов. 

### Оракулы в квантовых вычислениях 

**Оракул** — это квантовая подпрограмма или черный ящик, реализующий специфическую функцию f(x), которую можно применять к квантовым состояниям для извлечения полезной информации. Основная роль оракула в квантовых алгоритмах заключается в том, чтобы указать состояние, содержащее решение задачи, или преобразовать входные данные таким образом, чтобы решение стало более очевидным после использования квантовых операций, таких как суперпозиция и интерференция. 

## План исследования <a name="3"></a>

### 001. Базовые операции с кубитами
Создаем простую квантовую схему с одним кубитом. Инициализируем кубит и применяем к нему гейт Хадамара для перехода в суперпозицию. Затем выполняем измерение и выводим результаты.


### 002. Создание запутанных состояний
Создаем суперпозицию с помощью гейта Хадамара и фазового гейта. После этого измеряем распределение результатов, где оба кубита находятся в одинаковом состоянии, и применяем операторы для оценки ожидаемых значений.


### 003. Алгоритм Дойча-Йожи
Создаем две версии квантовой схемы для различных оракулов. Алгоритм возвращает результат измерения, по которому можно определить, является ли функция сбалансированной или константной.

### 004. Выполнение схемы на реальном квантовом процессоре IBM
Qiskit позволяет запускать квантовые схемы на реальных квантовых компьютерах при наличии токена доступа на IBM Quantum

### 005. Квантовая телепортация
`Квантовая телепортация — это передача состояния кубита от одного к другому при помощи запутанности и классической информации.`
Создаем схему, состоящую из трех кубитов, где состояние первого кубита передается третьему через запутывание и измерения.

### 006. Квантовый алгоритм Гровера
`Алгоритм Гровера — это алгоритм для поиска элемента в неупорядоченном массиве с квадратичным ускорением по сравнению с классическим поиском.`
Создаем оракул и применяем к нему оператор Гровера для нахождения нужного состояния.

### 007. Алгоритм Шора для факторизации
`Алгоритм Шора используется для факторизации целых чисел. Этот алгоритм требует значительных ресурсов для сложных чисел, поэтому он обычно запускается на специализированных симуляторах или реальных квантовых процессорах.`
Используем симулятор с упрощенной версией алгоритма. Выполним факторизацию числа 15. 

### 008. Квантовая ошибка и коррекция ошибок
В квантовых вычислениях ошибки возникают из-за потерь когерентности. Qiskit позволяет создавать коды коррекции ошибок для минимизации этих эффектов.
Разработаем трехкубитный код коррекции ошибок, который позволяет обнаруживать и исправлять одиночные ошибки на кубитах.

### 009. Построение собственных квантовых оракулов
В некоторых алгоритмах, таких как Гровер, требуется построить собственный оракул для поиска. Qiskit позволяет создавать произвольные оракулы.
Создадим оракул для состояния |11⟩ и применим его в квантовой схеме, подобной алгоритму Гровера

### 010. Квантовая криптография и протокол BB84
`Протокол BB84 — это метод квантового распределения ключей (QKD), который позволяет двум сторонам безопасно обмениваться ключом.`
Реализуем распределение ключа, где Алиса и Боб случайным образом выбирают базисы и квантовые биты. После измерения они сопоставляют базисы, и результаты используются для генерации секретного ключа.

### 011. Вариационный алгоритм квантовой аппроксимационной оптимизации (QAOA)
`QAOA — это алгоритм для решения комбинаторных задач оптимизации, таких как задача коммивояжера или задачи раскраски графов.`
Используем библиотеку qiskit_optimization для преобразования задачи MaxCut в оператор квантовой энергии (гамильтониан), а затем применяем QAOA для нахождения оптимального разреза графа. Результат демонстрирует минимальное значение гамильтониана и оптимальные параметры.

### 012. Вариационный алгоритм нахождения основного состояния (VQE)
`Вариационный алгоритм нахождения основного состояния (VQE) используется для нахождения минимального состояния энергии молекул, что применимо в квантовой химии.`
Находим минимальное состояние энергии для молекулы водорода, моделируя молекулу и её взаимодействия в квантовой цепи и применяя VQE для получения минимального энергетического уровня.

### 013. Квантовые нейронные сети (QNN)
`Квантовые нейронные сети (QNN) являются комбинацией квантовых вычислений и машинного обучения и могут использоваться для решения задач классификации и регрессии.`
Создадим квантовую нейронную сеть для классификации, используя TwoLayerQNN и обучив модель на симуляторе.

### 014. Адъюнтатные методы и квантовый градиентный спуск
`Градиентный спуск служит для оптимизации квантовых схем с помощью градиентных вычислений, что особенно полезно для обучения параметрических квантовых схем.`
Используем метод вычисления градиента параметра квантовой схемы

### 015. Квантовая Фурье-трансформация (QFT)
`Квантовая Фурье-трансформация (QFT) — это квантовый аналог дискретного преобразования Фурье, применяемый в квантовых алгоритмах, таких как алгоритм Шора.`
Реализуем QFT на трех кубитах. Цепь применяет последовательность гейтов Хадамара и контролируемых фазовых гейтов для реализации преобразования Фурье.

### 016. Моделирование квантовой динамики: эволюция Шредингера
`Квантовая динамика описывает, как квантовые состояния изменяются со временем под воздействием гамильтониана H, используя уравнение Шредингера.` 
Qiskit позволяет проводить такие симуляции, что находит применение в квантовой химии и физике. Создаем гамильтониан и вычисляем эволюцию начального состояния с учетом действия гамильтониана, что позволяет симулировать эволюцию сложных систем.

### 017. Квантовая коррекция ошибок: поверхностный код (surface code)
`Поверхностный код — это схема коррекции ошибок для квантовых компьютеров, которая использует решеточную структуру кубитов и защищает от ошибок через топологические свойства.`
Цепь демонстрирует упрощенную реализацию поверхностного кода для кодирования и декодирования логического кубита. В реальных системах поверхностный код строится на сетке и включает многоуровневую схему проверки ошибок.

### 018. Квантовая теория информации: Энтропия фон Неймана и взаимная информация
`Энтропия фон Неймана является мерой неопределенности в квантовой системе, тогда как взаимная информация позволяет измерить перепутанность между частями квантовой системы.`
Код создает запутанное состояние Белла и вычисляет его энтропию фон Неймана и взаимную информацию. Эти величины используются в квантовой теории информации для измерения количества информации и степени запутанности.

### 019. Квантовый алгоритм Гамильтоновой симуляции для больших систем
`Гамильтонова симуляция позволяет моделировать эволюцию больших квантовых систем, например, для молекул, атомов или даже квантовых материалов.`
В коде моделируется эволюция сложного гамильтониана с использованием метода троттеризации, что позволяет эффективно симулировать эволюцию сложных систем на квантовом компьютере.

### 020. Гибридные классические и квантовые алгоритмы для задач машинного обучения
`Квантовые компьютеры могут быть интегрированы с классическими алгоритмами для решения больших задач машинного обучения (например, кластеризация, классификация), где квантовый процесс используется для ускорения вычислений.`
Код реализует гибридную квантово-классическую модель SVC для классификации данных. Квантовая часть работает через feature map, а оптимизация параметров выполняется классическим образом.

## Настройка окружения <a name="4"></a>
### Требования по инструкциям из интернета
| № | Версия                | OS  |
|---|-----------------------| ----------------------------------- |
| 1 | Python 3.7            | Windows, Mac OS X, and Linux (Any) |
| 2 | Qiskit 0.21.0         | Windows, Mac OS X, and Linux (Any) |
| 3 | Anaconda Navigator 1.9 | Windows, Linux, macOS |

Необходимые библиотеки: 
- quiskit-terra 0.15.2 
- qiskit-aer 0.6.1 
- qiskit-ignis 0.4.0 
- qiskit-ibmq-provider 0.9.0 
- qiskit-aqua 0.7.5 
- qiskit 0.21.0

Мы работали с версиями python 3.7, 3.8, 3.10, но к сожалению, так и не смогли установить указанные старые версии библиотек.
Библиотеки с которыми мы работали сохранены командой `pip freeze > requirements.txt` в файл requirements.txt

## Результаты исследования <a name="5"></a>

В процессе нашего исследования мы столкнулись с рядом трудностей. К сожалению, многие библиотеки, актуальные в 2020-2021 годах, оказались несовместимыми в 2024 году. В частности, мы не смогли использовать следующие библиотеки:
- qiskit-optimization 
- qiskit.algorithms import Shor
- 'VQE' from 'qiskit_nature.algorithms
- 'PySCFDriver' from 'qiskit_nature.drivers'
- 'NeuralNetworkClassifier' from 'qiskit_machine_learning.neural_networks'

Также мы не смогли зарегистрировать аккаунт на IBM Quantum Platform из-за недоступности сервиса в России. При попытке регистрации появлялось сообщение:

`Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME.` 

По этой причине выполнение схемы на реальном квантовом процессоре IBM использовать не удалось.

Несмотря на возникшие трудности, наше исследование позволило нам ознакомиться с широким спектром возможностей квантовых вычислений, от реализации базовых квантовых операций до более сложных квантовых алгоритмов и систем коррекции ошибок.

Постепенно изучая тему от простого к сложному, мы смогли глубже понять, как работают квантовые алгоритмы и как квантовые вычисления могут изменить подход к решению сложных задач в области криптографии, оптимизации, моделирования и машинного обучения.

## Источники <a name="6"></a>
- Кайзер С., Гранад К. Изучаем квантовые вычисления на Python и Q# / пер. с анг. А. В. Логунова. – М.: ДМК Пресс, 2021 
- Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience // GitHub URL: https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience
- Qiskit Textbook content // GitHub URL: https://github.com/Qiskit/textbook/tree/main/notebooks/ch-algorithms#
- qiskit-machine-learning // GitHub URL: https://github.com/qiskit-community/qiskit-machine-learning/tree/main


## Авторы <a name="7"></a>
Работу выполнили студенты группы 22407:
- [Гордеев Никита](https://github.com/nikitagordeev10)
- [Ананьин Егор](https://github.com/Cleverking2003)
- Богатырев Павел


